package compute_test

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/fastly/go-fastly/v9/fastly"

	"github.com/fastly/cli/pkg/app"
	"github.com/fastly/cli/pkg/commands/compute"
	"github.com/fastly/cli/pkg/errors"
	"github.com/fastly/cli/pkg/global"
	"github.com/fastly/cli/pkg/manifest"
	"github.com/fastly/cli/pkg/mock"
	"github.com/fastly/cli/pkg/testutil"
	"github.com/fastly/cli/pkg/threadsafe"
)

// NOTE: Some tests don't provide a Service ID via any mechanism (e.g. flag
// or manifest) and if one is provided the test will fail due to a specific
// API call not being mocked. Be careful not to add a Service ID to all tests
// without first checking whether the Service ID is expected as the user flow
// for when no Service ID is provided is to create a new service.
//
// Additionally, stdin can be mocked in one of two ways...
//
// 1. Provide a single value.
// 2. Provide multiple values (one for each prompt expected).
//
// In the first case, the first prompt given to the user will get the value you
// defined in the testcase.stdin field, all other prompts will get an empty
// value. This has worked fine for the most part as the prompts have
// historically provided default values when an empty value is encountered.
//
// The second case is to address running the test code successfully as the
// business logic has changed over time to now 'require' values to be provided
// for some prompts, this means an empty string will break the test flow. If
// that's what you're encountering, then you should add multiple values for the
// testcase.stdin field so that there is a value provided for every prompt your
// testcase user flow expects to encounter.
func TestDeploy(t *testing.T) {
	if os.Getenv("TEST_COMPUTE_DEPLOY") == "" {
		t.Log("skipping test")
		t.Skip("Set TEST_COMPUTE_DEPLOY to run this test")
	}

	// We're going to chdir to a deploy environment,
	// so save the PWD to return to, afterwards.
	pwd, err := os.Getwd()
	if err != nil {
		t.Fatal(err)
	}

	// Create test environment
	rootdir := testutil.NewEnv(testutil.EnvOpts{
		T: t,
		Copy: []testutil.FileIO{
			{
				Src: filepath.Join("testdata", "deploy", "pkg", "package.tar.gz"),
				Dst: filepath.Join("pkg", "package.tar.gz"),
			},
		},
		Write: []testutil.FileIO{
			{
				Src: "This is my data for the KV Store 'store_one' baz field.",
				Dst: "kv_store_one_baz.txt",
			},
		},
	})
	defer os.RemoveAll(rootdir)

	// Before running the test, chdir into the build environment.
	// When we're done, chdir back to our original location.
	// This is so we can reliably copy the testdata/ fixtures.
	if err := os.Chdir(rootdir); err != nil {
		t.Fatal(err)
	}
	defer func() {
		_ = os.Chdir(pwd)
	}()

	originalPackageSizeLimit := compute.MaxPackageSize
	args := testutil.SplitArgs
	scenarios := []struct {
		api            mock.API
		args           []string
		dontWantOutput []string
		// There are two times the HTTPClient is used.
		// The first is if we need to activate a free trial.
		// The second is when we ping for service availability.
		// In this test case the free trial activation isn't used.
		// So we only define a single HTTP client call for service availability.
		httpClientRes        []*http.Response
		httpClientErr        []error
		manifest             string
		name                 string
		noManifest           bool
		reduceSizeLimit      bool
		stdin                []string
		wantError            string
		wantRemediationError string
		wantOutput           []string
	}{
		{
			name:                 "no fastly.toml manifest",
			args:                 args("compute deploy --token 123"),
			wantError:            "error reading fastly.toml",
			wantRemediationError: errors.ComputeInitRemediation,
			noManifest:           true,
		},
		{
			// If no Service ID defined via flag or manifest, then the expectation is
			// for the service to be created via the API and for the returned ID to
			// be stored into the manifest.
			//
			// Additionally it validates that the specified path (files generated by
			// the testutil.NewEnv()) cause no issues.
			name: "path with no service ID",
			args: args("compute deploy --token 123 -v --package pkg/package.tar.gz"),
			api: mock.API{
				ActivateVersionFn: activateVersionOk,
				CreateBackendFn:   createBackendOK,
				CreateDomainFn:    createDomainOK,
				CreateServiceFn:   createServiceOK,
				GetPackageFn:      getPackageOk,
				ListDomainsFn:     listDomainsOk,
				UpdatePackageFn:   updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"Deployed package (service 12345, version 1)",
			},
		},
		// Same validation as above with the exception that we use the default path
		// parsing logic (i.e. we don't explicitly pass a path via `-p` flag).
		{
			name: "empty service ID",
			args: args("compute deploy --token 123 -v"),
			api: mock.API{
				ActivateVersionFn: activateVersionOk,
				CreateBackendFn:   createBackendOK,
				CreateDomainFn:    createDomainOK,
				CreateServiceFn:   createServiceOK,
				GetPackageFn:      getPackageOk,
				ListDomainsFn:     listDomainsOk,
				UpdatePackageFn:   updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"Deployed package (service 12345, version 1)",
			},
		},
		{
			name: "list versions error",
			args: args("compute deploy --service-id 123 --token 123"),
			api: mock.API{
				GetServiceFn:   getServiceOK,
				ListVersionsFn: testutil.ListVersionsError,
			},
			wantError: fmt.Sprintf("error listing service versions: %s", testutil.Err.Error()),
		},
		{
			name: "service version is active, clone version error",
			args: args("compute deploy --service-id 123 --token 123 --version 1"),
			api: mock.API{
				CloneVersionFn:      testutil.CloneVersionError,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				ListVersionsFn:      testutil.ListVersions,
			},
			wantError: fmt.Sprintf("error cloning service version: %s", testutil.Err.Error()),
		},
		{
			name: "service version is locked, clone version error",
			args: args("compute deploy --service-id 123 --token 123 --version 2"),
			api: mock.API{
				CloneVersionFn:      testutil.CloneVersionError,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				ListVersionsFn:      testutil.ListVersions,
			},
			wantError: fmt.Sprintf("error cloning service version: %s", testutil.Err.Error()),
		},
		{
			name: "list domains error",
			args: args("compute deploy --service-id 123 --token 123"),
			api: mock.API{
				CloneVersionFn:      testutil.CloneVersionResult(4),
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsError,
				ListVersionsFn:      testutil.ListVersions,
			},
			wantError: fmt.Sprintf("error fetching service domains: %s", testutil.Err.Error()),
		},
		{
			name:                 "package size too large",
			args:                 args("compute deploy --package pkg/package.tar.gz --token 123"),
			reduceSizeLimit:      true,
			wantError:            "package size is too large",
			wantRemediationError: errors.PackageSizeRemediation,
		},
		// The following test doesn't just validate the package API error behaviour
		// but as a side effect it validates that when deleting the created
		// service, the Service ID is also cleared out from the manifest.
		{
			name: "package API error",
			args: args("compute deploy --token 123"),
			api: mock.API{
				CreateBackendFn: createBackendOK,
				CreateDomainFn:  createDomainOK,
				CreateServiceFn: createServiceOK,
				DeleteBackendFn: deleteBackendOK,
				DeleteDomainFn:  deleteDomainOK,
				DeleteServiceFn: deleteServiceOK,
				GetPackageFn:    getPackageOk,
				ListDomainsFn:   listDomainsOk,
				UpdatePackageFn: updatePackageError,
			},
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantError: fmt.Sprintf("error uploading package: %s", testutil.Err.Error()),
			wantOutput: []string{
				"Uploading package",
			},
		},
		// The following test doesn't provide a Service ID by either a flag nor the
		// manifest, so this will result in the deploy script attempting to create
		// a new service. We mock the API call to fail, and we expect to see a
		// relevant error message related to that error.
		{
			name: "service create error",
			args: args("compute deploy --token 123"),
			api: mock.API{
				CreateServiceFn: createServiceError,
				DeleteServiceFn: deleteServiceOK,
			},
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantError: fmt.Sprintf("error creating service: %s", testutil.Err.Error()),
		},
		// The following test mocks the service creation to fail with a specific
		// error value that will result in the code trying to activate a free trial
		// for the customer's account.
		//
		// Specifically this test will fail the initial API call to get the
		// customer's details and so we expect it to return that error (as we can't
		// activate a free trial without knowing the customer ID).
		{
			name: "service create error due to no trial activated and error getting user",
			args: args("compute deploy --token 123"),
			api: mock.API{
				CreateServiceFn:  createServiceErrorNoTrial,
				DeleteServiceFn:  deleteServiceOK,
				GetCurrentUserFn: getCurrentUserError,
			},
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantError: fmt.Sprintf("unable to identify user associated with the given token: %s", testutil.Err.Error()),
			wantOutput: []string{
				"Creating service",
			},
		},
		// The following test mocks the HTTP client to return a 400 Bad Request,
		// which is then coerced into a generic 'no free trial' error.
		{
			name: "service create error due to no trial activated and error activating trial",
			args: args("compute deploy --token 123"),
			api: mock.API{
				CreateServiceFn:  createServiceErrorNoTrial,
				DeleteServiceFn:  deleteServiceOK,
				GetCurrentUserFn: getCurrentUser,
			},
			httpClientRes: []*http.Response{
				{
					Body:       io.NopCloser(strings.NewReader(testutil.Err.Error())),
					Status:     http.StatusText(http.StatusBadRequest),
					StatusCode: http.StatusBadRequest,
				},
			},
			httpClientErr: []error{
				nil,
			},
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantError:            "error creating service: you do not have the Compute free trial enabled on your Fastly account",
			wantRemediationError: errors.ComputeTrialRemediation,
			wantOutput: []string{
				"Creating service",
			},
		},
		// The following test mocks the HTTP client to return a timeout error,
		// which is then coerced into a generic 'no free trial' error.
		{
			name: "service create error due to no trial activated and activating trial timeout",
			args: args("compute deploy --token 123"),
			api: mock.API{
				CreateServiceFn:  createServiceErrorNoTrial,
				DeleteServiceFn:  deleteServiceOK,
				GetCurrentUserFn: getCurrentUser,
			},
			httpClientRes: []*http.Response{
				nil,
			},
			httpClientErr: []error{
				&url.Error{Err: context.DeadlineExceeded},
			},
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantError:            "error creating service: you do not have the Compute free trial enabled on your Fastly account",
			wantRemediationError: errors.ComputeTrialRemediation,
			wantOutput: []string{
				"Creating service",
			},
		},
		// The following test mocks the HTTP client to return successfully when
		// trying to activate the free trial.
		{
			name: "service create success",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn: activateVersionOk,
				CreateBackendFn:   createBackendOK,
				CreateServiceFn:   createServiceOK,
				GetPackageFn:      getPackageOk,
				ListDomainsFn:     listDomainsOk,
				UpdatePackageFn:   updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"Creating service",
			},
		},
		// The following test doesn't provide a Service ID by either a flag nor the
		// manifest, so this will result in the deploy script attempting to create
		// a new service. We mock the service creation to be successful while we
		// mock the domain API call to fail, and we expect to see a relevant error
		// message related to that error.
		{
			name: "service domain error",
			args: args("compute deploy --token 123"),
			api: mock.API{
				CreateDomainFn:  createDomainError,
				CreateServiceFn: createServiceOK,
				DeleteDomainFn:  deleteDomainOK,
				DeleteServiceFn: deleteServiceOK,
				ListDomainsFn:   listDomainsNone,
			},
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantError: fmt.Sprintf("error creating domain: %s", testutil.Err.Error()),
			wantOutput: []string{
				"Creating service",
			},
		},
		// The following test doesn't provide a Service ID by either a flag nor the
		// manifest, so this will result in the deploy script attempting to create
		// a new service. We mock the service creation to be successful while we
		// mock the backend API call to succeed but to return an unexpected empty
		// list of Backends.
		{
			name: "service backend error",
			args: args("compute deploy --token 123"),
			api: mock.API{
				CreateBackendFn: createBackendError,
				CreateDomainFn:  createDomainOK,
				CreateServiceFn: createServiceOK,
				DeleteBackendFn: deleteBackendOK,
				DeleteDomainFn:  deleteDomainOK,
				DeleteServiceFn: deleteServiceOK,
				ListDomainsFn:   listDomainsOk,
			},
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantError: fmt.Sprintf("error configuring the service: %s", testutil.Err.Error()),
			wantOutput: []string{
				"Creating service",
			},
			dontWantOutput: []string{
				"Creating domain '",
			},
		},
		// The following test validates that the undoStack is executed as expected
		// e.g. the service is deleted when there is an error during the flow.
		// This only happens for new service flows.
		{
			name: "undo stack is executed",
			args: args("compute deploy --token 123"),
			api: mock.API{
				CreateBackendFn: createBackendError,
				CreateDomainFn:  createDomainOK,
				CreateServiceFn: createServiceOK,
				DeleteServiceFn: deleteServiceOK,
				ListDomainsFn:   listDomainsNone,
			},
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantError: fmt.Sprintf("error configuring the service: %s", testutil.Err.Error()),
			wantOutput: []string{
				"Cleaning up service",
				"Removing Service ID from fastly.toml",
				"Cleanup complete",
			},
		},
		// The following test is the opposite to the above test.
		// It validates that we don't delete an existing service on-error.
		{
			name: "undo stack is not executed for errors with existing services",
			args: args("compute deploy --service-id 123 --token 123"),
			api: mock.API{
				ActivateVersionFn:   activateVersionError,
				CloneVersionFn:      testutil.CloneVersionResult(4),
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			dontWantOutput: []string{
				"Cleaning up service",
				"Removing Service ID from fastly.toml",
				"Cleanup complete",
			},
			wantError: "error activating version: test error",
			wantOutput: []string{
				"Uploading package",
				"Activating service",
			},
		},
		// The following test validates that if a package contains code that has
		// not changed since the last deploy, then the deployment is skipped.
		{
			name: "identical package",
			args: args("compute deploy --service-id 123 --token 123"),
			api: mock.API{
				CloneVersionFn:      testutil.CloneVersionResult(4),
				GetPackageFn:        getPackageIdentical,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
			},
			wantOutput: []string{
				"Skipping package deployment",
			},
		},
		{
			name: "success with existing service",
			args: args("compute deploy --service-id 123 --token 123"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CloneVersionFn:      testutil.CloneVersionResult(4),
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			wantOutput: []string{
				"Uploading package",
				"Activating service",
				"Manage this service at:",
				"https://manage.fastly.com/configure/services/123",
				"View this service at:",
				"https://directly-careful-coyote.edgecompute.app",
				"Deployed package (service 123, version 4)",
			},
		},
		{
			name: "success with path",
			args: args("compute deploy --service-id 123 --token 123 --package pkg/package.tar.gz --version latest"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			wantOutput: []string{
				"Uploading package",
				"Activating service",
				"Manage this service at:",
				"https://manage.fastly.com/configure/services/123",
				"View this service at:",
				"https://directly-careful-coyote.edgecompute.app",
				"Deployed package (service 123, version 3)",
			},
		},
		// NOTE: The following test ensures that if the user runs the CLI from a
		// directory that isn't a Compute project directory (i.e. it has no manifest
		// file present) then the deploy command should try to locate a manifest
		// inside the given package tar.gz archive.
		{
			name: "success with path called from non project directory",
			args: args("compute deploy --service-id 123 --token 123 --package pkg/package.tar.gz --version latest --verbose"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			noManifest: true,
			wantOutput: []string{
				"Using fastly.toml within --package archive:",
				"Uploading package",
				"Activating service",
				"Manage this service at:",
				"https://manage.fastly.com/configure/services/123",
				"View this service at:",
				"https://directly-careful-coyote.edgecompute.app",
				"Deployed package (service 123, version 3)",
			},
		},
		{
			name: "success with inactive version",
			args: args("compute deploy --service-id 123 --token 123 --package pkg/package.tar.gz --version latest"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			wantOutput: []string{
				"Uploading package",
				"Activating service",
				"Deployed package (service 123, version 3)",
			},
		},
		{
			name: "success with specific locked version",
			args: args("compute deploy --service-id 123 --token 123 --package pkg/package.tar.gz --version 2"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CloneVersionFn:      testutil.CloneVersionResult(4),
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			wantOutput: []string{
				"Uploading package",
				"Activating service",
				"Deployed package (service 123, version 4)",
			},
		},
		{
			name: "success with active version",
			args: args("compute deploy --service-id 123 --token 123 --package pkg/package.tar.gz --version active"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CloneVersionFn:      testutil.CloneVersionResult(4),
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			wantOutput: []string{
				"Uploading package",
				"Activating service",
				"Deployed package (service 123, version 4)",
			},
		},
		{
			name: "success with comment",
			args: args("compute deploy --service-id 123 --token 123 --package pkg/package.tar.gz --version 2 --comment foo"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CloneVersionFn:      testutil.CloneVersionResult(4),
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
				UpdateVersionFn:     updateVersionOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			wantOutput: []string{
				"Uploading package",
				"Activating service",
				"Deployed package (service 123, version 4)",
			},
		},
		// The following test doesn't provide a Service ID by either a flag nor the
		// manifest, so this will result in the deploy script attempting to create
		// a new service. Our fastly.toml is configured with a [setup] section so
		// we expect to see the appropriate messaging in the output.
		{
			name: "success with setup.backends configuration",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn: activateVersionOk,
				CreateBackendFn:   createBackendOK,
				CreateDomainFn:    createDomainOK,
				CreateServiceFn:   createServiceOK,
				DeleteServiceFn:   deleteServiceOK,
				GetPackageFn:      getPackageOk,
				ListDomainsFn:     listDomainsOk,
				UpdatePackageFn:   updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.backends.backend_name]
			prompt = "Backend 1"
			address = "developer.fastly.com"
			port = 443
			[setup.backends.other_backend_name]
			prompt = "Backend 2"
			address = "httpbin.org"
			port = 443
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"Hostname or IP address: [developer.fastly.com]",
				"Port: [443]",
				"Hostname or IP address: [httpbin.org]",
				"Port: [443]",
				"Creating service",
				"Creating backend 'backend_name' (host: developer.fastly.com, port: 443)",
				"Creating backend 'other_backend_name' (host: httpbin.org, port: 443)",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
		},
		// The following [setup] configuration doesn't define any prompts, nor any
		// ports, so we validate that the user prompts match our default expectations.
		{
			name: "success with setup.backends configuration and no prompts or ports defined",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn: activateVersionOk,
				CreateBackendFn:   createBackendOK,
				CreateDomainFn:    createDomainOK,
				CreateServiceFn:   createServiceOK,
				DeleteServiceFn:   deleteServiceOK,
				GetPackageFn:      getPackageOk,
				ListDomainsFn:     listDomainsOk,
				UpdatePackageFn:   updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.backends.foo_backend]
			address = "developer.fastly.com"
			[setup.backends.bar_backend]
			address = "httpbin.org"
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"Hostname or IP address: [developer.fastly.com]",
				"Port: [443]",
				"Hostname or IP address: [httpbin.org]",
				"Port: [443]",
				"Creating service",
				"Creating backend 'foo_backend' (host: developer.fastly.com, port: 443)",
				"Creating backend 'bar_backend' (host: httpbin.org, port: 443)",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
			dontWantOutput: []string{
				"Creating domain '",
			},
		},
		{
			name: "success with setup.backends configuration but no fields for the required resources",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn: activateVersionOk,
				CreateBackendFn:   createBackendOK,
				CreateDomainFn:    createDomainOK,
				CreateServiceFn:   createServiceOK,
				DeleteServiceFn:   deleteServiceOK,
				GetPackageFn:      getPackageOk,
				ListDomainsFn:     listDomainsOk,
				UpdatePackageFn:   updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.backends.foo_backend]
			[setup.backends.bar_backend]
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"Configure a backend called 'foo_backend'",
				"Hostname or IP address: [127.0.0.1]",
				"Port: [443]",
				"Configure a backend called 'bar_backend'",
				"Hostname or IP address: [127.0.0.1]",
				"Port: [443]",
				"Creating service",
				"Creating backend 'foo_backend' (host: 127.0.0.1, port: 443)",
				"Creating backend 'bar_backend' (host: 127.0.0.1, port: 443)",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
			dontWantOutput: []string{
				"Creating domain '",
			},
		},
		// The following test validates no prompts are displayed to the user due to
		// the use of the --non-interactive flag.
		{
			name: "success with setup.backends configuration and non-interactive",
			args: args("compute deploy --non-interactive --token 123"),
			api: mock.API{
				ActivateVersionFn: activateVersionOk,
				CreateBackendFn:   createBackendOK,
				CreateDomainFn:    createDomainOK,
				CreateServiceFn:   createServiceOK,
				GetPackageFn:      getPackageOk,
				ListDomainsFn:     listDomainsOk,
				UpdatePackageFn:   updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.backends.backend_name]
			description = "Backend 1"
			address = "developer.fastly.com"
			port = 443
			[setup.backends.other_backend_name]
			description = "Backend 2"
			address = "httpbin.org"
			port = 443
			`,
			wantOutput: []string{
				"Creating service",
				"Creating backend 'backend_name' (host: developer.fastly.com, port: 443)",
				"Creating backend 'other_backend_name' (host: httpbin.org, port: 443)",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
			dontWantOutput: []string{
				"Backend 1: [developer.fastly.com]",
				"Backend port number: [443]",
				"Backend 2: [httpbin.org]",
				"Backend port number: [443]",
				"Domain: [",
			},
		},
		// The following test validates that a new 'originless' backend is created
		// when the user has no [setup] configuration and they also pass the
		// --non-interactive flag. This is done by ensuring we DON'T see the
		// standard 'Creating backend' output because we want to conceal the fact
		// that we require a backend for Compute services because it's a temporary
		// implementation detail.
		{
			name: "success with no setup.backends configuration and non-interactive for new service creation",
			args: args("compute deploy --non-interactive --token 123"),
			api: mock.API{
				ActivateVersionFn: activateVersionOk,
				CreateBackendFn:   createBackendOK,
				CreateDomainFn:    createDomainOK,
				CreateServiceFn:   createServiceOK,
				GetPackageFn:      getPackageOk,
				ListDomainsFn:     listDomainsOk,
				UpdatePackageFn:   updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			wantOutput: []string{
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
			dontWantOutput: []string{
				"Creating backend", // expect originless creation to be hidden
			},
		},
		{
			name: "success with no setup.backends configuration and single backend entered at prompt for new service",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn: activateVersionOk,
				CreateBackendFn:   createBackendOK,
				CreateDomainFn:    createDomainOK,
				CreateServiceFn:   createServiceOK,
				GetPackageFn:      getPackageOk,
				ListDomainsFn:     listDomainsOk,
				UpdatePackageFn:   updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			stdin: []string{
				"Y",      // when prompted to create a new service
				"foobar", // when prompted for service name
				"fastly.com",
				"443",
				"my_backend_name",
				"", // this stops prompting for backends
			},
			wantOutput: []string{
				"Backend (hostname or IP address, or leave blank to stop adding backends):",
				"Backend port number: [443]",
				"Backend name:",
				"Creating backend 'my_backend_name' (host: fastly.com, port: 443)",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
		},
		// This is the same test as above but when prompted it will provide two
		// backends instead of one, and will also allow the code to generate the
		// backend name using its predefined formula.
		{
			name: "success with no setup.backends configuration and multiple backends entered at prompt for new service",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn: activateVersionOk,
				CreateBackendFn:   createBackendOK,
				CreateDomainFn:    createDomainOK,
				CreateServiceFn:   createServiceOK,
				GetPackageFn:      getPackageOk,
				ListDomainsFn:     listDomainsOk,
				UpdatePackageFn:   updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			stdin: []string{
				"Y",          // when prompted to create a new service
				"foobar",     // when prompted for service name
				"fastly.com", // when prompted for a backend
				"443",
				"", // this is so we generate a backend name using a built-in formula
				"google.com",
				"123",
				"", // this is so we generate a backend name using a built-in formula
				"", // this stops prompting for backends
			},
			wantOutput: []string{
				"Backend (hostname or IP address, or leave blank to stop adding backends):",
				"Backend port number: [443]",
				"Backend name:",
				"Creating backend 'backend_1' (host: fastly.com, port: 443)",
				"Creating backend 'backend_2' (host: google.com, port: 123)",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
		},
		// The following test validates that when prompting the user for backends
		// that we'll default to creating an 'originless' backend if no value
		// provided at the prompt.
		{
			name: "success with no setup.backends configuration and defaulting to originless",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn: activateVersionOk,
				CreateBackendFn:   createBackendOK,
				CreateDomainFn:    createDomainOK,
				CreateServiceFn:   createServiceOK,
				GetPackageFn:      getPackageOk,
				ListDomainsFn:     listDomainsOk,
				UpdatePackageFn:   updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			stdin: []string{
				"Y",      // when prompted to create a new service
				"foobar", // when prompted for service name
				"",       // this stops prompting for backends
			},
			wantOutput: []string{
				"Backend (hostname or IP address, or leave blank to stop adding backends):",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
			dontWantOutput: []string{
				"Creating backend", // expect originless creation to be hidden
			},
		},
		// The following test is the same setup as above, but if the user provides
		// the --non-interactive flag we won't prompt for any backends.
		{
			name: "success with no setup.backends configuration and use of --non-interactive",
			args: args("compute deploy --non-interactive --token 123"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CreateBackendFn:     createBackendOK,
				CreateServiceFn:     createServiceOK,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			wantOutput: []string{
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
			dontWantOutput: []string{
				"Create new service",
				"Creating backend", // expect originless creation to be hidden
			},
		},
		// The following test validates that when dealing with an existing service,
		// no [setup.backends] configuration is utilised.
		//
		// i.e. we will not validate the service for missing backends, nor will we
		// prompt the user to create any backends.
		{
			name: "success with setup.backends configuration and existing service",
			args: args("compute deploy --service-id 123 --token 123"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CloneVersionFn:      testutil.CloneVersionResult(4),
				CreateBackendFn:     createBackendOK,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.backends.fastly]
			description = "Backend 1"
			address = "fastly.com"
			port = 443
			[setup.backends.google]
			description = "Backend 2"
			address = "google.com"
			port = 443
			[setup.backends.facebook]
			description = "Backend 3"
			address = "facebook.com"
			port = 443
			`,
			wantOutput: []string{
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 123, version 4)",
			},
			dontWantOutput: []string{
				"Creating backend 'google' (host: beep.com, port: 123)",
				"Creating backend 'facebook' (host: boop.com, port: 456)",
			},
		},
		{
			name: "success with setup.config_stores configuration and existing service",
			args: args("compute deploy --service-id 123 --token 123"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CloneVersionFn:      testutil.CloneVersionResult(4),
				CreateBackendFn:     createBackendOK,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.config_stores.example]
			description = "My first dictionary"
			[setup.config_stores.example.items.foo]
			value = "my default value for foo"
			description = "a good description about foo"
			[setup.config_stores.example.items.bar]
			value = "my default value for bar"
			description = "a good description about bar"
			`,
			wantOutput: []string{
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 123, version 4)",
			},
			dontWantOutput: []string{
				"Configuring dictionary 'dict_a'",
				"Create a config store key called 'foo'",
				"Create a config store key called 'bar'",
				"Creating config store 'example'",
				"Creating config store item 'foo'",
				"Creating config store item 'bar'",
			},
		},
		{
			name: "success with setup.config_stores configuration and no existing service",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn:       activateVersionOk,
				CreateBackendFn:         createBackendOK,
				CreateConfigStoreFn:     createConfigStoreOK,
				CreateDomainFn:          createDomainOK,
				CreateResourceFn:        createResourceOK,
				CreateServiceFn:         createServiceOK,
				GetPackageFn:            getPackageOk,
				GetServiceDetailsFn:     getServiceDetailsWasm,
				GetServiceFn:            getServiceOK,
				ListConfigStoresFn:      listConfigStoresEmpty,
				ListDomainsFn:           listDomainsOk,
				ListVersionsFn:          testutil.ListVersions,
				UpdateConfigStoreItemFn: updateConfigStoreItemOK,
				UpdatePackageFn:         updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.config_stores.example]
			description = "My first store"
			[setup.config_stores.example.items.foo]
			value = "my default value for foo"
			description = "a good description about foo"
			[setup.config_stores.example.items.bar]
			value = "my default value for bar"
			description = "a good description about bar"
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"Configuring config store 'example'",
				"My first store",
				"Create a config store key called 'foo'",
				"my default value for foo",
				"Create a config store key called 'bar'",
				"my default value for bar",
				"Creating config store 'example'",
				"Creating config store item 'foo'",
				"Creating config store item 'bar'",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
		},
		{
			name: "success with setup.config_stores configuration and no existing service and a conflicting store name",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn:       activateVersionOk,
				CreateBackendFn:         createBackendOK,
				CreateConfigStoreFn:     createConfigStoreOK,
				CreateDomainFn:          createDomainOK,
				CreateResourceFn:        createResourceOK,
				CreateServiceFn:         createServiceOK,
				GetConfigStoreFn:        getConfigStoreOk,
				GetPackageFn:            getPackageOk,
				GetServiceDetailsFn:     getServiceDetailsWasm,
				GetServiceFn:            getServiceOK,
				ListConfigStoresFn:      listConfigStoresOk,
				ListDomainsFn:           listDomainsOk,
				ListVersionsFn:          testutil.ListVersions,
				UpdateConfigStoreItemFn: updateConfigStoreItemOK,
				UpdatePackageFn:         updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.config_stores.example]
			description = "My first store"
			[setup.config_stores.example.items.foo]
			value = "my default value for foo"
			description = "a good description about foo"
			[setup.config_stores.example.items.bar]
			value = "my default value for bar"
			description = "a good description about bar"
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"WARNING: A Config Store called 'example' already exists",
				"Retrieving existing Config Store 'example'",
				"Configuring config store 'example'",
				"My first store",
				"Create a config store key called 'foo'",
				"my default value for foo",
				"Create a config store key called 'bar'",
				"my default value for bar",
				"Creating config store item 'foo'",
				"Creating config store item 'bar'",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
		},
		{
			name: "success with setup.config_stores configuration and no existing service and --non-interactive",
			args: args("compute deploy --non-interactive --token 123"),
			api: mock.API{
				ActivateVersionFn:       activateVersionOk,
				CreateBackendFn:         createBackendOK,
				CreateConfigStoreFn:     createConfigStoreOK,
				CreateDomainFn:          createDomainOK,
				CreateResourceFn:        createResourceOK,
				CreateServiceFn:         createServiceOK,
				GetPackageFn:            getPackageOk,
				GetServiceDetailsFn:     getServiceDetailsWasm,
				GetServiceFn:            getServiceOK,
				ListConfigStoresFn:      listConfigStoresEmpty,
				ListDomainsFn:           listDomainsOk,
				ListVersionsFn:          testutil.ListVersions,
				UpdateConfigStoreItemFn: updateConfigStoreItemOK,
				UpdatePackageFn:         updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.config_stores.example]
			description = "My first store"
			[setup.config_stores.example.items.foo]
			value = "my default value for foo"
			description = "a good description about foo"
			[setup.config_stores.example.items.bar]
			value = "my default value for bar"
			description = "a good description about bar"
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"Creating config store 'example'",
				"Creating config store item 'foo'",
				"Creating config store item 'bar'",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
		},
		{
			name: "success with setup.config_stores configuration and no existing service and no predefined values",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn:       activateVersionOk,
				CreateBackendFn:         createBackendOK,
				CreateConfigStoreFn:     createConfigStoreOK,
				CreateDomainFn:          createDomainOK,
				CreateResourceFn:        createResourceOK,
				CreateServiceFn:         createServiceOK,
				GetPackageFn:            getPackageOk,
				GetServiceDetailsFn:     getServiceDetailsWasm,
				GetServiceFn:            getServiceOK,
				ListConfigStoresFn:      listConfigStoresEmpty,
				ListDomainsFn:           listDomainsOk,
				ListVersionsFn:          testutil.ListVersions,
				UpdateConfigStoreItemFn: updateConfigStoreItemOK,
				UpdatePackageFn:         updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.config_stores.example]
			[setup.config_stores.example.items.foo]
			[setup.config_stores.example.items.bar]
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"Configuring config store 'example'",
				"Create a config store key called 'foo'",
				"Create a config store key called 'bar'",
				"Creating config store 'example'",
				"Creating config store item 'foo'",
				"Creating config store item 'bar'",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
			// The following are predefined values for the `description` and `value`
			// fields from the prior setup.config_stores tests that we expect to not
			// be present in the stdout/stderr as the [setup.config_stores]
			// configuration does not define them.
			dontWantOutput: []string{
				"My first store",
				"my default value for foo",
				"my default value for bar",
			},
		},
		{
			name: "success with setup.log_entries configuration and existing service",
			args: args("compute deploy --service-id 123 --token 123"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CloneVersionFn:      testutil.CloneVersionResult(4),
				CreateBackendFn:     createBackendOK,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.log_endpoints.foo]
			provider = "BigQuery"
			`,
			wantOutput: []string{
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 123, version 4)",
			},
			dontWantOutput: []string{
				"The package code requires the following log endpoints to be created.",
				"Name: foo",
				"Provider: BigQuery",
				"Refer to the help documentation for each provider (if no provider shown, then select your own):",
				"fastly logging <provider> create --help",
			},
		},
		{
			name: "success with setup.log_entries configuration and no existing service",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn:      activateVersionOk,
				CreateBackendFn:        createBackendOK,
				CreateDictionaryFn:     createDictionaryOK,
				CreateDictionaryItemFn: createDictionaryItemOK,
				CreateDomainFn:         createDomainOK,
				CreateServiceFn:        createServiceOK,
				GetPackageFn:           getPackageOk,
				GetServiceDetailsFn:    getServiceDetailsWasm,
				GetServiceFn:           getServiceOK,
				ListDomainsFn:          listDomainsOk,
				ListVersionsFn:         testutil.ListVersions,
				UpdatePackageFn:        updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.log_endpoints.foo]
			provider = "BigQuery"
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"The package code requires the following log endpoints to be created.",
				"Name: foo",
				"Provider: BigQuery",
				"Refer to the help documentation for each provider (if no provider shown, then select your own):",
				"fastly logging <provider> create --help",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
		},
		{
			name: "success with setup.log_entries configuration and no existing service and no provider defined",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn:      activateVersionOk,
				CreateBackendFn:        createBackendOK,
				CreateDictionaryFn:     createDictionaryOK,
				CreateDictionaryItemFn: createDictionaryItemOK,
				CreateDomainFn:         createDomainOK,
				CreateServiceFn:        createServiceOK,
				GetPackageFn:           getPackageOk,
				GetServiceDetailsFn:    getServiceDetailsWasm,
				GetServiceFn:           getServiceOK,
				ListDomainsFn:          listDomainsOk,
				ListVersionsFn:         testutil.ListVersions,
				UpdatePackageFn:        updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.log_endpoints.foo]
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"The package code requires the following log endpoints to be created.",
				"Name: foo",
				"Refer to the help documentation for each provider (if no provider shown, then select your own):",
				"fastly logging <provider> create --help",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
			dontWantOutput: []string{
				"Provider: BigQuery",
			},
		},
		{
			name: "success with setup.log_entries configuration and no existing service, but a provider defined",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn:      activateVersionOk,
				CreateBackendFn:        createBackendOK,
				CreateDictionaryFn:     createDictionaryOK,
				CreateDictionaryItemFn: createDictionaryItemOK,
				CreateDomainFn:         createDomainOK,
				CreateServiceFn:        createServiceOK,
				GetPackageFn:           getPackageOk,
				GetServiceDetailsFn:    getServiceDetailsWasm,
				GetServiceFn:           getServiceOK,
				ListDomainsFn:          listDomainsOk,
				ListVersionsFn:         testutil.ListVersions,
				UpdatePackageFn:        updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.log_endpoints.foo]
			provider = "BigQuery"
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"The package code requires the following log endpoints to be created.",
				"Name: foo",
				"Provider: BigQuery",
				"Refer to the help documentation for each provider (if no provider shown, then select your own):",
				"fastly logging <provider> create --help",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
		},
		// NOTE: The following test validates [setup] only works for a new service.
		{
			name: "success with setup.kv_stores configuration and existing service",
			args: args("compute deploy --service-id 123 --token 123"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CloneVersionFn:      testutil.CloneVersionResult(4),
				CreateBackendFn:     createBackendOK,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.kv_stores.store_one]
			description = "My first KV Store"
			[setup.kv_stores.store_one.items.foo]
			value = "my default value for foo"
			description = "a good description about foo"
			[setup.kv_stores.store_one.items.bar]
			value = "my default value for bar"
			description = "a good description about bar"
			`,
			wantOutput: []string{
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 123, version 4)",
			},
			dontWantOutput: []string{
				"Configuring KV Store 'store_one'",
				"Create a KV Store key called 'foo'",
				"Create a KV Store key called 'bar'",
				"Creating KV Store 'store_one'",
				"Creating KV Store key 'foo'",
				"Creating KV Store key 'bar'",
			},
		},
		{
			name: "success with setup.kv_stores configuration and no existing service plus use of file and existing store",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CreateBackendFn:     createBackendOK,
				CreateDomainFn:      createDomainOK,
				CreateResourceFn:    createResourceOK,
				CreateServiceFn:     createServiceOK,
				GetKVStoreFn:        getKVStoreOk,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				InsertKVStoreKeyFn:  createKVStoreItemOK,
				ListDomainsFn:       listDomainsOk,
				ListKVStoresFn:      listKVStoresOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.kv_stores.store_one]
			description = "My first KV Store"
			[setup.kv_stores.store_one.items.foo]
			value = "my default value for foo"
			description = "a good description about foo"
			[setup.kv_stores.store_one.items.bar]
			value = "my default value for bar"
			description = "a good description about bar"
			[setup.kv_stores.store_one.items.baz]
			file = "./kv_store_one_baz.txt"
			description = "a file containing the data for this key"
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"WARNING: A KV Store called 'store_one' already exists",
				"Retrieving existing KV Store 'store_one'",
				"Create a KV Store key called 'foo'",
				"Create a KV Store key called 'bar'",
				"Create a KV Store key called 'baz'",
				"Creating KV Store key 'foo'",
				"Creating KV Store key 'bar'",
				"Creating KV Store key 'baz'",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
		},
		{
			name: "error with setup.kv_stores configuration and no existing service with file and value on same key",
			args: args("compute deploy --token 123"),
			api: mock.API{
				CreateBackendFn:     createBackendOK,
				CreateDomainFn:      createDomainOK,
				CreateKVStoreFn:     createKVStoreOK,
				CreateResourceFn:    createResourceOK,
				CreateServiceFn:     createServiceOK,
				DeleteServiceFn:     deleteServiceOK,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				InsertKVStoreKeyFn:  createKVStoreItemOK,
				ListDomainsFn:       listDomainsOk,
				ListKVStoresFn:      listKVStoresEmpty,
				ListVersionsFn:      testutil.ListVersions,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.kv_stores.store_one]
			description = "My first KV Store"
			[setup.kv_stores.store_one.items.baz]
      value = "some_value"
			file = "./kv_store_one_baz.txt"
			description = "a file containing the data for this key"
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"Configuring KV Store 'store_one'",
			},
			wantError: "invalid config: both 'value' and 'file' were set",
		},
		{
			name: "success with setup.kv_stores configuration and no existing service and --non-interactive",
			args: args("compute deploy --non-interactive --token 123"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CreateBackendFn:     createBackendOK,
				CreateDomainFn:      createDomainOK,
				CreateKVStoreFn:     createKVStoreOK,
				CreateResourceFn:    createResourceOK,
				CreateServiceFn:     createServiceOK,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				InsertKVStoreKeyFn:  createKVStoreItemOK,
				ListDomainsFn:       listDomainsOk,
				ListKVStoresFn:      listKVStoresEmpty,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.kv_stores.store_one]
			description = "My first KV Store"
			[setup.kv_stores.store_one.items.foo]
			value = "my default value for foo"
			description = "a good description about foo"
			[setup.kv_stores.store_one.items.bar]
			value = "my default value for bar"
			description = "a good description about bar"
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"Creating KV Store 'store_one'",
				"Creating KV Store key 'foo'",
				"Creating KV Store key 'bar'",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
		},
		{
			name: "success with setup.kv_stores configuration and no existing service and no predefined values",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CreateBackendFn:     createBackendOK,
				CreateDomainFn:      createDomainOK,
				CreateKVStoreFn:     createKVStoreOK,
				CreateResourceFn:    createResourceOK,
				CreateServiceFn:     createServiceOK,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				InsertKVStoreKeyFn:  createKVStoreItemOK,
				ListDomainsFn:       listDomainsOk,
				ListKVStoresFn:      listKVStoresEmpty,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.kv_stores.store_one]
			[setup.kv_stores.store_one.items.foo]
			[setup.kv_stores.store_one.items.bar]
			`,
			stdin: []string{
				"Y", // when prompted to create a new service
			},
			wantOutput: []string{
				"Configuring KV Store 'store_one'",
				"Create a KV Store key called 'foo'",
				"Create a KV Store key called 'bar'",
				"Creating KV Store 'store_one'",
				"Creating KV Store key 'foo'",
				"Creating KV Store key 'bar'",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
			// The following are predefined values for the `description` and `value`
			// fields from the prior setup.dictionaries tests that we expect to not
			// be present in the stdout/stderr as the [setup/dictionaries]
			// configuration does not define them.
			dontWantOutput: []string{
				"My first KV Store",
				"my default value for foo",
				"my default value for bar",
			},
		},
		// NOTE: The following test validates [setup] only works for a new service.
		{
			name: "success with setup.secret_stores configuration and existing service",
			args: args("compute deploy --service-id 123 --token 123"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CloneVersionFn:      testutil.CloneVersionResult(4),
				CreateBackendFn:     createBackendOK,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.secret_stores.store_one]
			description = "My first Secret Store"
			[setup.secret_stores.store_one.entries.foo]
			description = "a good description about foo"
			[setup.secret_stores.store_one.entries.bar]
			description = "a good description about bar"
			`,
			wantOutput: []string{
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 123, version 4)",
			},
			dontWantOutput: []string{
				"Configuring Secret Store 'store_one'",
				"Create a Secret Store entry called 'foo'",
				"Create a Secret Store entry called 'bar'",
				"Creating Secret Store 'store_one'",
				"Creating Secret Store entry 'foo'",
				"Creating Secret Store entry 'bar'",
			},
		},
		{
			name: "success with setup.secret_stores configuration and no existing service but an existing store",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CreateBackendFn:     createBackendOK,
				CreateDomainFn:      createDomainOK,
				CreateResourceFn:    createResourceOK,
				CreateSecretFn:      createSecretOk,
				CreateServiceFn:     createServiceOK,
				GetPackageFn:        getPackageOk,
				GetSecretStoreFn:    getSecretStoreOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListSecretStoresFn:  listSecretStoresOk,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.secret_stores.store_one]
			description = "My first Secret Store"
			[setup.secret_stores.store_one.entries.foo]
			description = "a good description about foo"
			[setup.secret_stores.store_one.entries.bar]
			description = "a good description about bar"
			[setup.secret_stores.store_one.entries.baz]
			description = "a file containing the data for this entry"
			`,
			stdin: []string{
				"Y",         // when prompted to create a new service
				"",          // leave blank for service name prompt
				"",          // leave blank for backend prompt
				"",          // leave blank for using existing store prompt
				"my_secret", // when prompted to add a secret for foo (this can't be empty)
				"my_secret", // when prompted to add a secret for bar (this can't be empty)
				"my_secret", // when prompted to add a secret for baz (this can't be empty)
			},
			wantOutput: []string{
				"WARNING: A Secret Store called 'store_one' already exists",
				"Retrieving existing Secret Store 'store_one'",
				"Create a Secret Store entry called 'foo'",
				"Create a Secret Store entry called 'bar'",
				"Create a Secret Store entry called 'baz'",
				"Creating Secret Store entry 'foo'",
				"Creating Secret Store entry 'bar'",
				"Creating Secret Store entry 'baz'",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
		},
		{
			name: "success with setup.secret_stores configuration and no existing service and no predefined values",
			args: args("compute deploy --token 123"),
			api: mock.API{
				ActivateVersionFn:   activateVersionOk,
				CreateBackendFn:     createBackendOK,
				CreateDomainFn:      createDomainOK,
				CreateResourceFn:    createResourceOK,
				CreateSecretFn:      createSecretOk,
				CreateSecretStoreFn: createSecretStoreOk,
				CreateServiceFn:     createServiceOK,
				GetPackageFn:        getPackageOk,
				GetServiceDetailsFn: getServiceDetailsWasm,
				GetServiceFn:        getServiceOK,
				ListDomainsFn:       listDomainsOk,
				ListSecretStoresFn:  listSecretStoresEmpty,
				ListVersionsFn:      testutil.ListVersions,
				UpdatePackageFn:     updatePackageOk,
			},
			httpClientRes: []*http.Response{
				mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
				mock.NewHTTPResponse(http.StatusOK, nil, io.NopCloser(strings.NewReader("success"))),
			},
			httpClientErr: []error{
				nil,
				nil,
			},
			manifest: `
			name = "package"
			manifest_version = 2
			language = "rust"

			[setup.secret_stores.store_one]
			[setup.secret_stores.store_one.entries.foo]
			[setup.secret_stores.store_one.entries.bar]
			`,
			stdin: []string{
				"Y",         // when prompted to create a new service
				"",          // leave blank for service name prompt
				"",          // leave blank for backend prompt
				"my_secret", // when prompted to add a secret for foo (this can't be empty)
				"my_secret", // when prompted to add a secret for bar (this can't be empty)
			},
			wantOutput: []string{
				"Configuring Secret Store 'store_one'",
				"Create a Secret Store entry called 'foo'",
				"Create a Secret Store entry called 'bar'",
				"Creating Secret Store 'store_one'",
				"Creating Secret Store entry 'foo'",
				"Creating Secret Store entry 'bar'",
				"Uploading package",
				"Activating service",
				"SUCCESS: Deployed package (service 12345, version 1)",
			},
			// The following are predefined values for the `description` and `value`
			// fields from the prior setup.dictionaries tests that we expect to not
			// be present in the stdout/stderr as the [setup/dictionaries]
			// configuration does not define them.
			dontWantOutput: []string{
				"My first Secret Store",
				"my default value for foo",
				"my default value for bar",
			},
		},
	}
	for testcaseIdx := range scenarios {
		testcase := &scenarios[testcaseIdx]
		t.Run(testcase.name, func(t *testing.T) {
			// Because the manifest can be mutated on each test scenario, we recreate
			// the file each time.
			manifestContent := `manifest_version = 2
			name = "package"
			`
			if testcase.manifest != "" {
				manifestContent = testcase.manifest
			}
			if err := os.WriteFile(filepath.Join(rootdir, manifest.Filename), []byte(manifestContent), 0o600); err != nil {
				t.Fatal(err)
			}

			// For any test scenario that expects no manifest to exist, then instead
			// of deleting the manifest and having to recreate it, we'll simply
			// rename it, and then rename it back once the specific test scenario has
			// finished running.
			if testcase.noManifest {
				old := filepath.Join(rootdir, manifest.Filename)
				tmp := filepath.Join(rootdir, manifest.Filename+"Tmp")
				if err := os.Rename(old, tmp); err != nil {
					t.Fatal(err)
				}
				defer func() {
					if err := os.Rename(tmp, old); err != nil {
						t.Fatal(err)
					}
				}()
			}

			var stdout threadsafe.Buffer
			opts := testutil.MockGlobalData(testcase.args, &stdout)
			opts.APIClientFactory = mock.APIClient(testcase.api)

			if testcase.httpClientRes != nil || testcase.httpClientErr != nil {
				opts.HTTPClient = mock.HTMLClient(testcase.httpClientRes, testcase.httpClientErr)
			}

			if testcase.reduceSizeLimit {
				compute.MaxPackageSize = 1000000 // 1mb (our test package should above this)
			} else {
				// As multiple test scenarios run within a single environment instance
				// we need to ensure each scenario resets the package variable.
				compute.MaxPackageSize = originalPackageSizeLimit
			}

			if len(testcase.stdin) > 1 {
				// To handle multiple prompt input from the user we need to do some
				// coordination around io pipes to mimic the required user behaviour.
				stdin, prompt := io.Pipe()
				opts.Input = stdin

				// Wait for user input and write it to the prompt
				inputc := make(chan string)
				go func() {
					for input := range inputc {
						fmt.Fprintln(prompt, input)
					}
				}()

				// We need a channel so we wait for `run()` to complete
				done := make(chan bool)

				// Call `app.Run()` and wait for response
				go func() {
					app.Init = func(_ []string, _ io.Reader) (*global.Data, error) {
						return opts, nil
					}
					err = app.Run(testcase.args, nil)
					done <- true
				}()

				// User provides input
				//
				// NOTE: Must provide as much input as is expected to be waited on by `run()`.
				//       For example, if `run()` calls `input()` twice, then provide two messages.
				//       Otherwise the select statement will trigger the timeout error.
				for _, input := range testcase.stdin {
					inputc <- input
				}

				select {
				case <-done:
					// Wait for app.Run() to finish
				case <-time.After(10 * time.Second):
					t.Log(stdout.String())
					t.Fatalf("unexpected timeout waiting for mocked prompt inputs to be processed")
				}
			} else {
				stdin := ""
				if len(testcase.stdin) > 0 {
					stdin = testcase.stdin[0]
				}
				opts.Input = strings.NewReader(stdin)
				app.Init = func(_ []string, _ io.Reader) (*global.Data, error) {
					return opts, nil
				}
				err = app.Run(testcase.args, nil)
			}

			t.Log(stdout.String())

			testutil.AssertErrorContains(t, err, testcase.wantError)
			testutil.AssertRemediationErrorContains(t, err, testcase.wantRemediationError)

			for _, s := range testcase.wantOutput {
				testutil.AssertStringContains(t, stdout.String(), s)
			}

			for _, s := range testcase.dontWantOutput {
				testutil.AssertStringDoesntContain(t, stdout.String(), s)
			}
		})
	}
}

func TestDeploy_ActivateBeacon(t *testing.T) {
	// We're going to chdir to a deploy environment,
	// so save the PWD to return to, afterwards.
	pwd, err := os.Getwd()
	if err != nil {
		t.Fatal(err)
	}

	// Create test environment
	rootdir := testutil.NewEnv(testutil.EnvOpts{
		T: t,
		Copy: []testutil.FileIO{
			{
				Src: filepath.Join("testdata", "deploy", "pkg", "package.tar.gz"),
				Dst: filepath.Join("pkg", "package.tar.gz"),
			},
		},
		Write: []testutil.FileIO{
			{
				Src: "This is my data for the KV Store 'store_one' baz field.",
				Dst: "kv_store_one_baz.txt",
			},
		},
	})
	defer os.RemoveAll(rootdir)

	// Before running the test, chdir into the build environment.
	// When we're done, chdir back to our original location.
	// This is so we can reliably copy the testdata/ fixtures.
	if err := os.Chdir(rootdir); err != nil {
		t.Fatal(err)
	}
	defer func() {
		_ = os.Chdir(pwd)
	}()

	stdout := threadsafe.Buffer{}
	args := testutil.SplitArgs("compute deploy --auto-yes --non-interactive")
	recordingHTTP := &mock.HTTPClient{
		Responses: []*http.Response{
			// the body is closed by beacon.Notify
			//nolint: bodyclose
			mock.NewHTTPResponse(http.StatusNoContent, nil, nil),
		},
		Errors: []error{
			nil,
		},
		Index:        -1,
		SaveRequests: true,
	}

	manifestContent := `
	name = "package"
	manifest_version = 2
	language = "rust"
	`

	if err := os.WriteFile(filepath.Join(rootdir, manifest.Filename), []byte(manifestContent), 0o600); err != nil {
		t.Fatal(err)
	}

	opts := testutil.MockGlobalData(args, &stdout)
	opts.HTTPClient = recordingHTTP
	opts.APIClientFactory = mock.APIClient(mock.API{
		ActivateVersionFn: func(*fastly.ActivateVersionInput) (*fastly.Version, error) {
			return nil, testutil.Err
		},
		CloneVersionFn:      testutil.CloneVersionResult(4),
		CreateBackendFn:     createBackendOK,
		CreateServiceFn:     createServiceOK,
		DeleteServiceFn:     deleteServiceOK,
		GetPackageFn:        getPackageOk,
		GetServiceDetailsFn: getServiceDetailsWasm,
		GetServiceFn:        getServiceOK,
		ListDomainsFn:       listDomainsOk,
		ListVersionsFn:      testutil.ListVersions,
		UpdatePackageFn:     updatePackageOk,
	})

	app.Init = func(_ []string, stdin io.Reader) (*global.Data, error) {
		opts.Input = stdin
		return opts, nil
	}

	err = app.Run(args, nil)

	testutil.AssertErrorContains(t, err, "error activating version:")
	testutil.AssertLength(t, 1, recordingHTTP.Requests)

	beaconReq := recordingHTTP.Requests[0]
	testutil.AssertEqual(t, "fastly-notification-relay.edgecompute.app", beaconReq.URL.Hostname())
}

func createServiceOK(i *fastly.CreateServiceInput) (*fastly.Service, error) {
	return &fastly.Service{
		ServiceID: fastly.ToPointer("12345"),
		Name:      i.Name,
		Type:      i.Type,
	}, nil
}

func createServiceError(*fastly.CreateServiceInput) (*fastly.Service, error) {
	return nil, testutil.Err
}

// NOTE: We don't return testutil.Err but a very specific error message so that
// the Deploy logic will drop into a nested logic block.
func createServiceErrorNoTrial(*fastly.CreateServiceInput) (*fastly.Service, error) {
	return nil, fmt.Errorf("Valid values for 'type' are: 'vcl'")
}

func getCurrentUser() (*fastly.User, error) {
	return &fastly.User{
		CustomerID: fastly.ToPointer("abc"),
	}, nil
}

func getCurrentUserError() (*fastly.User, error) {
	return nil, testutil.Err
}

func deleteServiceOK(_ *fastly.DeleteServiceInput) error {
	return nil
}

func createDomainError(_ *fastly.CreateDomainInput) (*fastly.Domain, error) {
	return nil, testutil.Err
}

func deleteDomainOK(_ *fastly.DeleteDomainInput) error {
	return nil
}

func createBackendError(_ *fastly.CreateBackendInput) (*fastly.Backend, error) {
	return nil, testutil.Err
}

func deleteBackendOK(_ *fastly.DeleteBackendInput) error {
	return nil
}

func getPackageIdentical(i *fastly.GetPackageInput) (*fastly.Package, error) {
	return &fastly.Package{
		ServiceID:      fastly.ToPointer(i.ServiceID),
		ServiceVersion: fastly.ToPointer(i.ServiceVersion),
		Metadata: &fastly.PackageMetadata{
			FilesHash: fastly.ToPointer("d8786807216a37608ecd0bc2357c86f883faad89043141f0a147f2c186ce0212333d31229399c131539205908f5cf0884ea64552782544ff9b27416cd5b996b2"),
			HashSum:   fastly.ToPointer("bf634ccf8be5c8417cf562466ece47ea61056ddeb07273a3d861e8ad757ed3577bc182006d04093c301467cadfd2b1805eedebd1e7cfa0404c723680f2dbc01e"),
		},
	}, nil
}

func activateVersionError(_ *fastly.ActivateVersionInput) (*fastly.Version, error) {
	return nil, testutil.Err
}

func listDomainsError(_ *fastly.ListDomainsInput) ([]*fastly.Domain, error) {
	return nil, testutil.Err
}

func listDomainsNone(_ *fastly.ListDomainsInput) ([]*fastly.Domain, error) {
	return []*fastly.Domain{}, nil
}
